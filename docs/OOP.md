1. Object-Oriented Programming
   - Object : 물체, 개체 (객체는 주체의 반의어이므로 오역)
   - 자바가 OOP에 관해서 더 엄격

2. C++ OOP
   - 클래스
   - 개체
   - 생성자
   - 함수 오버로딩
   - 힙에 개체 생성하기
   - 스택에 개체 생성하기
   - 복사 생성자
   - 소멸자 
   - 연산자 오버로딩

3. 누군가가 OOP를 복잡하게 만들었다 (단, 유용한 것도 있음)
   - 개채지향 분석과 디자인 (OOAD)
   - 디자인 패턴

4. 스택
   - 예약된 로컬메모리 공간. 일반적으로 1MB 이하
   - 함수 호출과 반환이 이 메모리에서 일어남
   - 스택에 할당된 메모리는 범위를 벗어나면 사라짐
   - 단순히 스택 포인터를 옮김
   - 메모리를 할당 및 해제할 필요가 없음
   - 변수와 매개변수를 위해 필요한 크기는 컴파일 도중에 알 수 있음
   - 스택에 큰 개체를 많이 넣으면 스택오버플로우가 발생할 수 있음
5. 힙
   - 전역 메모리 공간. OS가 지원하는 무수한 메모리 공간.
   - 비어있고 연속된 메모리 블록을 찾아야함
   - 프로그래머가 **직접 할당 및 해제**해야 함

6. Java가 멤버변수를 초기화하는 방법유추

   ```c
   // Vector의 멤버변수는 모두 int형을 가정
   Vector a = new Vector();
   // Vector크기만큼의 메모리 할당
   void* ptr = malloc(sizeof(Vector));
   // Vector크기만큼의 영역을 0으로 메모리 셋(카피)
   // 모든 비트패턴이 0이면? → 0(정수), 0.0(부동소수점), null로 판단 함
   memset(ptr, 0, sizeof(Vector));
   // 멤버변수 0으로 전부 초기화된 Vector의 포인터를 반환 (new Vector())
   a = (Vector*)ptr;
   ```

7. new/delete와 malloc(), free()의 차이는 무엇일까

   - malloc(), free()

     ```yml
     - 라이브러리 함수
     - 헤더파일 필요
     - 쓰임/상황에 따라 오버로딩 가능
     ```

   - new, delete

     ```yml
     - 언어가 제공하는 연산자
     - 별도의 헤더파일 불필요
     - new 연산자로 객체를 할당할 때 생성자가 자동으로 호출된다. 생성자가 생성과 동시에 객체를 초기화 시키는 것으로, 반드시 초기화 되어야하는 기존 타입과 동등한 자격을 가질 수 있게된다.
     ```

   - 할당과 해제는 섞어쓸 수 없다. new로 할당한 메모리는 delete로 해제해야하고 malloc()으로 할당한 메모리는 free로 해제해야한다.

